/**
 * @file usbd_vcom.h
 * @date 2015-10-08
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * USBD_VCOM v4.0.10 - The USB virtual COM port driver for XMC4000 family of controllers
 *
 * Copyright (c) 2015, Infineon Technologies AG
 * All rights reserved.                        
 *                                             
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the           
 * following conditions are met:   
 *                                                                              
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following   
 *   disclaimer.                        
 * 
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following   
 *   disclaimer in the documentation and/or other materials provided with the distribution.     
 *                         
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote 
 *   products derived from this software without specific prior written permission. 
 *                                             
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,  
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE   
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,  
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR        
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,      
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE   
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.    
 *                                                                              
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes       
 * with Infineon Technologies AG (dave@infineon.com).         
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version.
 *           
 * 2015-03-18:
 *     - Updated the review comments from AEs.    
 * 2015-06-20:
 *     - Updated the file header.
 *
 * @endcond 
 *
 */


#ifndef USBD_VCOM_H
#define USBD_VCOM_H

/* Enable C linkage for C++ Compilers: */
#if defined(__cplusplus)
	extern "C" {
#endif

/***********************************************************************************************************************
 * HEADER FILES                                                                                                      
 **********************************************************************************************************************/
  /* Includes: */
#include <xmc_common.h>
#include <DAVE_Common.h>
#include "./class_driver/cdc_class.h"
#include "./virtual_com/descriptors.h"
#include "../USBD/usbd.h"
#include "./usbd_vcom_conf.h"

/**********************************************************************************************************************
 * MACROS                                                                                                            
 **********************************************************************************************************************/
/**
 * @ingroup USBD_VCOM_constants
 * @{
 */
/**< USB product ID for the VCOM application*/
#define USBD_VCOM_PRODUCT_ID				(0x0058)

/**< Infineon USB vendor ID*/
#define IFX_USB_VENDOR_ID					(0x058B)

/**< Endpoint0 maximum packet size for USBD VCOM application.*/
#define USBD_VCOM_EP0_SIZE					(64U)

/**< The USB specification supported by VCOM application.*/
#define USBD_VCOM_FS_SPEC					(0x0110)

/**< Manufacturer string index for USBD VCOM application.*/
#define USBD_VCOM_MANUF_STRING_INDEX		1U

/**< Product string index for the USBD VCOM application.*/
#define USBD_VCOM_PROD_STRING_INDEX			2U



/**
 * @}
 */


/**********************************************************************************************************************
 * ENUMS
 **********************************************************************************************************************/
/**
 * @ingroup USBD_VCOM_enumerations
 * @{
 */
/**
 * This enumerates USBD_VCOM APP status.
 */

typedef enum USBD_VCOM_Status
{
	/**
	* USB VCOM device Module success
	*/
	USBD_VCOM_STATUS_SUCCESS = 0U,

	/**
	* USB VCOM device Module Error
	*/
	USBD_VCOM_STATUS_FAILURE,

	/**
	* Device is attached
	*/
	USBD_VCOM_STATUS_DEVICE_ATTACHED,
	/**
	* Device is enumerated by the Host
	*/
	USBD_VCOM_STATUS_DEVICE_ENUM_COMPLETE,
	/**
	* Device is unattached
	*/
	USBD_VCOM_STATUS_DEVICE_UNATTACHED,
	/**
	* Sub-Error of an Error.
	*/
	USBD_VCOM_STATUS_CDC_SUB_ERROR,
	/**
	* USB CDC Error.
	*/
	USBD_VCOM_STATUS_CDC_ERROR

} USBD_VCOM_STATUS_t;

/**
 * @}
 */

/**********************************************************************************************************************
 * DATA STRUCTURES
 **********************************************************************************************************************/
/**
 * @ingroup USBD_VCOM_datastructures
 * @{
 */
	/**
	 * The structure to hold the CDC class event call backs
	 **/
	typedef struct
	{
		/**< CDC device line encoding change event.\n
		 *  CDC class driver event for a line encoding change on a CDC interface. This event
		 *  fires each time the host requests a line encoding change (containing the serial parity,
		 *  baud and other configuration information). The new line encoding settings are available
		 *  in the LineEncoding structure inside the CDC interface structure passed as a parameter.
		 **/
		void (*LineEncodingChanged)(USB_ClassInfo_CDC_Device_t* const cdc_interface_info);


		/**
		 * CDC device control line state changed event.\n
		 * CDC class driver event for a control line state change on a CDC interface. This event fires
		 * each time the host requests a control line state change (containing the virtual serial control
		 * line states, such as DTR).The new control line states are available in the ControlLineStates.
		 * HostToDevice value inside the CDC interface structure passed as a parameter.
		 **/
		void (*ControLineStateChanged)(USB_ClassInfo_CDC_Device_t* const cdc_interface_info);

		/**
		 * CDC class send break event.\n CDC class driver event for a send break request sent to
		 * the device from the host.This is generally used to separate data or to indicate a special
		 * condition to the receiving device.
		 **/
		void (*Device_BreakSent)(USB_ClassInfo_CDC_Device_t* const cdc_interface_info,const uint8_t duration);

	}USB_CDCClass_event_CB_t;

	/**
	 * @}
	 */


	/**
	 * @ingroup USBD_VCOM_datastructures
	 * @{
	 */

	/**
	 * The structure contains the CDC class event flags.
	 * These flags can be polled from the top level applications.
	 **/
	typedef struct
	{
		/**< The flag to indicate the CDC class event, line encoding changed.*/
		volatile uint8_t line_encoding_event_flag;

		/**< The flag to indicate the CDC class event, control line state changed.*/
		volatile uint8_t control_line_state_change_event_flag;

		/**< The flag to indicate the CDC class event, send break from CDC host.*/
		volatile uint8_t break_event_flag;
	}CDC_Class_Event_Flags_t;
	/**
	 * @}
	 */

	/**
	 * @ingroup USBD_VCOM_datastructures
	 * @{
	 */

	/**
	 * The structure contains the configuration parameters for USBD_VCOM APP handle.
	 * Currently this is a dummy handle and configuration parameters can be added later, if required.
	 **/
	typedef struct
	{
		uint8_t dummy;/**< The dummy variable to avoid compilation error on non GCC compilers*/
	}USBD_VCOM_t;

/**
 * @}
 */

/*extern declarations*/
#include "usbd_vcom_extern.h"


/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/
/**
 * @ingroup USBD_VCOM_apidoc
 * @{
 */

/**
 * @brief Initializes the USB core layer to make the device ready to connect to USB host.
 * @param vcom_handle Pointer to VCOM device handle ::USBD_VCOM_t
 * @return ::USBD_VCOM_STATUS_t
 *
 * \par<b>Description:</b><br>
 * Registers USB event call backs and initializes USB core.\n
 *       This function :\n
 *       1) Registers the USB Device Events.\n
 *       2) Initializes the USB core driver.\n
 * The ::USBD_VCOM_Init() is called inside the DAVE_Init().\n
 * \par<b>Note:</b><br>
 * The ::USBD_VCOM_Connect() needs to be called from user application to connect to the USBD host or to trigger the USB enumeration.\n
 * Example Usage:
 * As part of DAVE_Init(), the USBD_VCOM_Init() is invoked and user does not have to explicitly call the API USBD_VCOM_Init().\n
 * Please see the example code for ::USBD_VCOM_Connect API for the application code.
 */
USBD_VCOM_STATUS_t USBD_VCOM_Init(USBD_VCOM_t *vcom_handle);


/**
 * @brief Connects the XMC USB VCOM device to the USB host.
 * @param None
 * @return ::USBD_VCOM_STATUS_t
 *
 * \par<b>Description:</b><br>
 *       In order to call USBD_VCOM_Connect()  following procedure should be followed:\n
 *        1) Call DAVE_Init().::USBD_VCOM_Init() is called inside DAVE_Init().\n
 *        2) Call ::USBD_VCOM_Connect() to connect the device to USB host.
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * int8_t rx_buffer[64] = { 0 };
 * int8_t tx_buffer[64] = { 0 };
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   uint16_t bytes = 0;
 *
 *   init_status = DAVE_Init();
 *
 *   if (init_status == DAVE_STATUS_SUCCESS)
 *   {
 *     if (USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
 *     {
 *       return -1;
 *     }
 *
 *     while(!USBD_VCOM_IsEnumDone());
 *
 *     while(1U)
 *     {
 *       bytes = USBD_VCOM_BytesReceived();
 *
 *       if (bytes)
 *       {
 *         if (bytes == 1)
 *         {
 *           USBD_VCOM_ReceiveByte(&rx_buffer[0]);
 *
 *           USBD_VCOM_SendByte(rx_buffer[0]);
 *
 *         }
 *         else
 *         {
 *           USBD_VCOM_ReceiveData(rx_buffer, bytes);
 *           memcpy(tx_buffer, rx_buffer, bytes);
 *           USBD_VCOM_SendData((const int8_t *)&tx_buffer[0], bytes);
 *         }
 *
 *       }
 *       CDC_Device_USBTask(&USBD_VCOM_cdc_interface);
 *     }
 *   }
 *   else
 *   {
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *   }
 *
 *   return 1U;
 * }
 *  @endcode
 */
USBD_VCOM_STATUS_t USBD_VCOM_Connect(void);

/**
 * @brief Disconnects the XMC USB device from the USB host.
 * @param None
 * @return ::USBD_VCOM_STATUS_t
 *
 * \par<b>Description:</b><br>
 *       In order to call USBD_VCOM_Disconnect()  following procedure should be followed:\n
 *        1) Call DAVE_Init().::USBD_VCOM_Init() is called inside DAVE_Init().\n
 *        2) Call ::USBD_VCOM_Connect() to connect the device to USB host.
 *        3) Check the enumeration status by using API ::USBD_VCOM_IsEnumDone().\n
 *        4) On scenario, where user want to disconnect the device from USB host, call ::USBD_VCOM_Disconnect().
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * int8_t rx_buffer[64] = { 0 };
 * int8_t tx_buffer[64] = { 0 };
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *
 *   init_status = DAVE_Init();
 *
 *   if (init_status == DAVE_STATUS_SUCCESS)
 *   {
 *     if(USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
 *     {
 *       return -1;
 *     }
 *
 *     while (!USBD_VCOM_IsEnumDone());
 *
 *     if(USBD_VCOM_Disconnect() != USBD_VCOM_STATUS_SUCCESS)
 *     {
 *     }
 *   }
 *   else
 *   {
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *   }
 *
 *   return 1U;
 * }
 *  @endcode
 */
  USBD_VCOM_STATUS_t USBD_VCOM_Disconnect(void);

/**
 * @brief Sends one byte of data to the USB host.
 * @param data_byte The data byte to be send.
 * @return ::USBD_VCOM_STATUS_t
 * \par<b>Description:</b><br>
 *        In order to call USBD_VCOM_SendByte()  following procedure should be followed:\n
 *        1) Call DAVE_Init().\n
 *        2) Call ::USBD_VCOM_Connect().\n
 *        3) Check the enumeration status by using API ::USBD_VCOM_IsEnumDone().\n
 *        4) After enumeration completion, Call ::USBD_VCOM_SendByte().\n
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * int8_t rx_buffer[64] = { 0 };
 * int8_t tx_buffer[64] = { 0 };
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   uint16_t bytes = 0;
 *
 *   init_status = DAVE_Init();
 *
 *   if (init_status == DAVE_STATUS_SUCCESS)
 *   {
 *     if (USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
 *     {
 *       return -1;
 *     }
 *
 *     while (!USBD_VCOM_IsEnumDone());
 *
 *     while(1U)
 *     {
 *       bytes = USBD_VCOM_BytesReceived();
 *
 *       if (bytes)
 *       {
 *         if (bytes == 1)
 *         {
 *           USBD_VCOM_ReceiveByte(&rx_buffer[0]);
 *
 *           USBD_VCOM_SendByte(rx_buffer[0]);
 *
 *         }
 *
 *       }
 *       CDC_Device_USBTask(&USBD_VCOM_cdc_interface);
 *     }
 *   }
 *   else
 *   {
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *   }
 *
 *   return 1U;
 * }
 *  @endcode
 */
USBD_VCOM_STATUS_t USBD_VCOM_SendByte(const uint8_t data_byte);

/**
 * @brief Send multiple bytes of data to the USB host.
 * @param data_buffer Pointer to the user buffer containing the data to be send.
 * @param length Number of bytes to be send to the USB host.
 * @return ::USBD_VCOM_STATUS_t
 *
 * \par<b>Description:</b><br>
 *        In order to call USBD_VCOM_SendData()  following procedure should be followed:\n
 *        1) Call DAVE_Init().\n
 *        2) Call ::USBD_VCOM_Connect().\n
 *        3) Check the enumeration status by using API ::USBD_VCOM_IsEnumDone().\n
 *        4) After enumeration completion, Call ::USBD_VCOM_SendData().\n
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * int8_t rx_buffer[64] = { 0 };
 * int8_t tx_buffer[64] = { 0 };
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   uint16_t bytes = 0;
 *
 *   init_status = DAVE_Init();
 *
 *   if (init_status == DAVE_STATUS_SUCCESS)
 *   {
 *     if (USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
 *     {
 *       return -1;
 *     }
 *
 *     while (!USBD_VCOM_IsEnumDone());
 *
 *     while(1U)
 *     {
 *       bytes = USBD_VCOM_BytesReceived();
 *
 *       if (bytes)
 *       {
 *         if (bytes == 1)
 *         {
 *           USBD_VCOM_ReceiveByte(&rx_buffer[0]);
 *
 *           USBD_VCOM_SendByte(rx_buffer[0]);
 *
 *         }
 *         else
 *         {
 *           USBD_VCOM_ReceiveData(rx_buffer, bytes);
 *           memcpy(tx_buffer, rx_buffer, bytes);
 *           USBD_VCOM_SendData((const int8_t *)&tx_buffer[0], bytes);
 *         }
 *
 *       }
 *       CDC_Device_USBTask(&USBD_VCOM_cdc_interface);
 *     }
 *   }
 *   else
 *   {
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *   }
 *
 *   return 1U;
 * }
 *  @endcode
 */
USBD_VCOM_STATUS_t USBD_VCOM_SendData(const int8_t* const data_buffer,
                              const uint16_t length);

/**
 * @brief Send string to the USB host.
 * @param data_string Pointer to the user buffer containing the string to be send.
 * @return ::USBD_VCOM_STATUS_t
 *
 * \par<b>Description:</b><br>
 *        In order to call USBD_VCOM_SendString()  following procedure should be followed:\n
 *        1) Call DAVE_Init().\n
 *        2) Call ::USBD_VCOM_Connect().\n
 *        3) Check the enumeration status by using API ::USBD_VCOM_IsEnumDone().\n
 *        4) After enumeration done, Call ::USBD_VCOM_SendString().\n
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * int8_t rx_buffer[64] = { 0 };
 * int8_t tx_buffer[64] = { 0 };
 *
 * static void delay(uint32_t cycles);
 *
 * static void delay(uint32_t cycles)
 * {
 *   volatile uint32_t i;
 *
 *   for(i = 0UL; i < cycles ;++i)
 *   {
 *      __NOP();
 *   }
 * }
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *
 *   init_status = DAVE_Init();
 *
 *   if (init_status == DAVE_STATUS_SUCCESS)
 *   {
 *
 *     if (USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
 *     {
 *       return -1;
 *     }
 *
 *     while (!USBD_VCOM_IsEnumDone());
 *     while(!cdc_event_flags.line_encoding_event_flag);
 *
 *     delay(0xffff);//ensure the status of line encoding request is properly send to host.
 *
 *     while(1U)
 *     {
 *       USBD_VCOM_SendString((int8_t*)"Hello World\t");
 *
 *       CDC_Device_USBTask(&USBD_VCOM_cdc_interface);
 *     }
 *   }
 *   else
 *   {
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *   }
 *
 *   return 1U;
 * }
 *  @endcode
 */
USBD_VCOM_STATUS_t USBD_VCOM_SendString(const int8_t* const data_string);

/**
 * @brief Receives a byte from the USB host.
 * @param data_byte Pointer to the user buffer to store the received byte.
 * @return ::USBD_VCOM_STATUS_t
 *
 * \par<b>Description:</b><br>
 * In order to call USBD_VCOM_ReceiveByte()  following procedure should be followed:\n
 *   1) Call DAVE_Init().\n
 *   2) Call ::USBD_VCOM_Connect().\n
 *   3) Check the enumeration status by using API ::USBD_VCOM_IsEnumDone().\n
 *   4) Call ::USBD_VCOM_BytesReceived() to check the number of bytes received from host.\n
 *   5) Call ::USBD_VCOM_ReceiveByte() to receive the data from the host.\n
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * int8_t rx_buffer[64] = { 0 };
 * int8_t tx_buffer[64] = { 0 };
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   uint16_t bytes = 0;
 *
 *   init_status = DAVE_Init();
 *
 *   if (init_status == DAVE_STATUS_SUCCESS)
 *   {
 *     if (USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
 *     {
 *       return -1;
 *     }
 *
 *     while (!USBD_VCOM_IsEnumDone());
 *
 *     while(1U)
 *     {
 *       bytes = USBD_VCOM_BytesReceived();
 *
 *       if (bytes)
 *       {
 *         if (bytes == 1)
 *         {
 *           USBD_VCOM_ReceiveByte(&rx_buffer[0]);
 *
 *           USBD_VCOM_SendByte(rx_buffer[0]);
 *
 *         }
 *
 *       }
 *       CDC_Device_USBTask(&USBD_VCOM_cdc_interface);
 *     }
 *   }
 *   else
 *   {
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *   }
 *
 *   return 1U;
 * }
 *  @endcode
 */
USBD_VCOM_STATUS_t USBD_VCOM_ReceiveByte(int8_t* data_byte);

/**
 * @brief Receives number of bytes of data from the USB host.
 * @param data_buffer Pointer to the user buffer to store the received data.
 * @param data_byte Number of bytes to be received from USB host.
 * @return ::USBD_VCOM_STATUS_t
 *
 * \par<b>Description:</b><br>
 *        In order to call USBD_VCOM_ReceiveData()  following procedure should be followed:\n
 *        1) Call DAVE_Init().\n
 *        2) Call ::USBD_VCOM_Connect().\n
 *        3) Check the enumeration status by using API ::USBD_VCOM_IsEnumDone().\n
 *        4) Call ::USBD_VCOM_BytesReceived().\n
 *        5) Call ::USBD_VCOM_ReceiveData().\n
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * int8_t rx_buffer[64] = { 0 };
 * int8_t tx_buffer[64] = { 0 };
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   uint16_t bytes = 0;
 *
 *   init_status = DAVE_Init();
 *
 *   if (init_status == DAVE_STATUS_SUCCESS)
 *   {
 *     if (USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
 *     {
 *       return -1;
 *     }
 *
 *     while (!USBD_VCOM_IsEnumDone());
 *
 *     while(1U)
 *     {
 *       bytes = USBD_VCOM_BytesReceived();
 *
 *       if (bytes)
 *       {
 *           USBD_VCOM_ReceiveData(rx_buffer, bytes);
 *           memcpy(tx_buffer, rx_buffer, bytes);
 *           USBD_VCOM_SendData((const int8_t *)&tx_buffer[0], bytes);
 *
 *       }
 *       CDC_Device_USBTask(&USBD_VCOM_cdc_interface);
 *     }
 *   }
 *   else
 *   {
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *   }
 *
 *   return 1U;
 * }
 *  @endcode
 */
USBD_VCOM_STATUS_t USBD_VCOM_ReceiveData(int8_t* data_buffer, uint16_t data_byte);

/**
 * @brief Receives number of bytes of data from the USB host.
 * @param None.
 * @return uint16_t Number of bytes received.
 *
 * \par<b>Description:</b><br>
 *       In order to call USBD_VCOM_BytesReceived()  following procedure should be followed:\n
 *        1) Call DAVE_Init().\n
 *        2) ::USBD_VCOM_Connect().\n
 *        3) Check the enumeration status by using API ::USBD_VCOM_IsEnumDone().\n
 *        4) Call ::USBD_VCOM_BytesReceived().\n
 *
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * int8_t rx_buffer[64] = { 0 };
 * int8_t tx_buffer[64] = { 0 };
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *   uint16_t bytes = 0;
 *
 *   init_status = DAVE_Init();
 *
 *   if (init_status == DAVE_STATUS_SUCCESS)
 *   {
 *     if (USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
 *     {
 *       return -1;
 *     }
 *     while (!USBD_VCOM_IsEnumDone());
 *
 *     while(1U)
 *     {
 *       bytes = USBD_VCOM_BytesReceived();
 *
 *       if (bytes)
 *       {
 *         if (bytes == 1)
 *         {
 *           USBD_VCOM_ReceiveByte(&rx_buffer[0]);
 *           USBD_VCOM_SendByte(rx_buffer[0]);
 *
 *         }
 *
 *       }
 *       CDC_Device_USBTask(&USBD_VCOM_cdc_interface);
 *     }
 *   }
 *   else
 *   {
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *   }
 *
 *   return 1U;
 * }
 *  @endcode
 */
  uint16_t USBD_VCOM_BytesReceived(void);
  
 /**
 * @brief Gets the CDC line encoding data.
 * @param line_encoding_ptr Pointer to the line encoding data structure ::CDC_LineEncoding.
 * @return ::USBD_VCOM_STATUS_t
 *
 * \par<b>Description:</b><br>
 *        In order to call USBD_VCOM_GetLineEncoding()  following procedure should be followed:\n
 *        1) Call DAVE_Init().\n
 *        2) Call ::USBD_VCOM_Connect().\n
 *        3) Check the enumeration status by using API ::USBD_VCOM_IsEnumDone().\n
 *        4) After enumeration call ::USBD_VCOM_GetLineEncoding().\n
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * CDC_LineEncoding_t line_encoding_ptr;
 *
 * int8_t rx_buffer[64] = { 0 };
 * int8_t tx_buffer[64] = { 0 };
 * static void delay(uint32_t cycles);
 *
 * static void delay(uint32_t cycles)
 * {
 *   volatile uint32_t i;
 *
 *   for(i = 0UL; i < cycles ;++i)
 *   {
 *      __NOP();
 *   }
 * }
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *
 *   init_status = DAVE_Init();
 *
 *   if (init_status == DAVE_STATUS_SUCCESS)
 *   {
 *     if (USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
 *     {
 *       return -1;
 *     }
 *
 *     while (!USBD_VCOM_IsEnumDone());
 *     while(!cdc_event_flags.line_encoding_event_flag);
 *
 *     delay(0xffff);//ensure the status of line encoding request is properly send to host.
 *
 *     USBD_VCOM_GetLineEncoding(&line_encoding_ptr);
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *   else
 *   {
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *   }
 *
 *   return 1U;
 * }
 *  @endcode
 */
  USBD_VCOM_STATUS_t USBD_VCOM_GetLineEncoding(CDC_LineEncoding_t* line_encoding_ptr);

 /**
 * @brief Gets the enumeration completion status of USB device.
 * @param None.
 * @return uint32_t<br>
 *         Returns 1, if the enumeration is done and 0 otherwise.
 * \par<b>Description:</b><br>
 * In order to call USBD_VCOM_IsEnumDone()  following procedure should be followed:\n
 *        1) Call DAVE_Init().\n
 *        2) Call ::USBD_VCOM_Connect().\n
 *        3) Call ::USBD_VCOM_IsEnumDone().\n
 * Example Usage:
 * @code
 * #include <DAVE.h>
 *
 * CDC_LineEncoding_t line_encoding_ptr;
 *
 * int8_t rx_buffer[64] = { 0 };
 * int8_t tx_buffer[64] = { 0 };
 * static void delay(uint32_t cycles);
 *
 * static void delay(uint32_t cycles)
 * {
 *   volatile uint32_t i;
 *
 *   for(i = 0UL; i < cycles ;++i)
 *   {
 *      __NOP();
 *   }
 * }
 *
 * int main(void)
 * {
 *   DAVE_STATUS_t init_status;
 *
 *   init_status = DAVE_Init();
 *
 *   if (init_status == DAVE_STATUS_SUCCESS)
 *   {
 *     if (USBD_VCOM_Connect() != USBD_VCOM_STATUS_SUCCESS)
 *     {
 *       return -1;
 *     }
 *
 *     while (!USBD_VCOM_IsEnumDone());
 *     while(!cdc_event_flags.line_encoding_event_flag);
 *
 *     delay(0xffff);//ensure the status of line encoding request is properly send to host.
 *
 *     USBD_VCOM_GetLineEncoding(&line_encoding_ptr);
 *
 *     while(1U)
 *     {
 *
 *     }
 *   }
 *   else
 *   {
 *     XMC_DEBUG("main: Application initialization failed");
 *     while(1U)
 *     {
 *     }
 *   }
 *
 *   return 1U;
 * }
 *  @endcode
 **/
  uint32_t USBD_VCOM_IsEnumDone(void);

  /**
   * @brief Get USBD_VCOM APP version
   * @return ::DAVE_APP_VERSION_t APP version information (major, minor and patch number)
   *
   * \par<b>Description: </b><br>
   * The function can be used to check application software compatibility with a
   * specific version of the APP.
   *
   * Example Usage:
   *
   * @code
   * #include <DAVE.h>
   *
   * int main(void) {
   *   DAVE_APP_VERSION_t version;
   *
   *   version = USBD_VCOM_GetAppVersion();
   *   if (version.major != 4U) {
   *     // Probably, not the right version.
   *   }
   *
   *   // More code here
   *   while(1) {
   *
   *   }
   *   return (0);
   * }
   * @endcode<BR>
   */
  DAVE_APP_VERSION_t USBD_VCOM_GetAppVersion(void);


  /**
   * Registers the USB event call backs with low level driver.
   **/
  USBD_VCOM_STATUS_t USBD_VCOM_Register_USBEvent_CB(USBD_Event_CB_t *event_callback);

  /**
   * Event for USB configuration number changed. This event fires when a the USB host changes the selected configuration number.
   * This event should be hooked in device applications to create the endpoints and configure the device for the selected configuration.
   * This event is time-critical; exceeding OS-specific delays within this event handler (typically of around one second) will prevent
   * the device from enumerating correctly.
   *
   *  This event fires after the value of configuration number has been changed.
   */
  void USBD_VCOM_Event_ConfigurationChanged(void);

  /**
   * Event for control requests. This event fires when a the USB host issues a control request to the mandatory device control
   *  endpoint (of address 0). This may either be a standard request that the library may have a handler code for internally,
   *   or a class specific request issued to the device which must be handled appropriately. If a request is not processed in the
   *  user application via this event, it will be passed to the library for processing internally if a suitable handler exists.
   *
   *  This event is time-critical; each packet within the request transaction must be acknowledged or sent within 50ms or the host
   *  will abort the transfer.
   *
   *  The library internally handles all standard control requests with the exceptions of SYNC FRAME,  SET DESCRIPTOR and
   *  SET INTERFACE. These and all other non-standard control requests will be left for the user to process via this event if desired.
   *  If not handled in the user application or by the library internally, unknown requests are automatically STALLed.
   **/
  void USBD_VCOM_Event_ControlRequest(void);

  /**
   * USB Get descriptor event handler. This function is called by the library when in device mode. When the device receives a
   * Get Descriptor request on the control endpoint, this function is called so that the descriptor details can be passed back
   * and the appropriate descriptor sent back to the USB host.
   * The user has to send proper descriptor(device,configuration and string) and should return the size of the descriptor data.
   **/
  uint16_t USBD_VCOM_Event_GetDescriptor(const uint16_t w_value,
                                        const uint16_t w_index,
                                        const void** const descriptor_address);
  /**
   * Event for USB interface reset. This event fires when the USB interface is in device mode, and  the USB host requests that
   * the device reset its interface. This event fires after the control endpoint has been automatically configured by the library.
   *
   *  This event is time-critical; exceeding OS-specific delays within this event handler (typically of around  two seconds)
   *  will prevent the device from enumerating correctly.
   **/
  void USBD_VCOM_Event_Reset(void);

  /**
   * CDC class driver event for a line encoding change on a CDC interface. This event fires each time the host
   * requests a line encoding change (containing the serial parity, baud and other configuration information). The new
   * line encoding settings are available in the LineEncoding structure inside the CDC interface structure passed
   * as a parameter.*/
  void USBD_VCOM_CDCClass_Event_LineEncodingChanged(USB_ClassInfo_CDC_Device_t* const cdc_interface_info);

  /**
   * CDC class driver event for a control line state change on a CDC interface. This event fires
   * each time the host requests a control line state change (containing the virtual serial control
   * line states, such as DTR).The new control line states are available in the ControlLineStates.HostToDevice
   * value inside the CDC interface structure passed as a parameter. */
  void USBD_VCOM_CDCClass_Event_ControlLineStateChanged(USB_ClassInfo_CDC_Device_t* const cdc_interface_info);

  /**
   * CDC class driver event for a send break request sent to the device from the host.
   * This is generally used to separate data or to indicate a special condition to the receiving device.*/
  void USBD_VCOM_CDCClass_Event_BreakSent(USB_ClassInfo_CDC_Device_t* const cdc_interface_info,	const uint8_t duration);

  /**
   * @}
   */

  /*Disable C linkage for C++ Compilers: */
	#if defined(__cplusplus)
		}
	#endif
#endif /*USBD_VCOM_H*/
