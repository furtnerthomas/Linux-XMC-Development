/**
 * @file usbd.h
 * @date 2016-02-10
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 *
 * @cond
 ***********************************************************************************************************************
 * USBD v4.0.14 - The USB core driver for XMC4000 family of controllers. It does the USB protocol handling.
 *
 * Copyright (c) 2015, Infineon Technologies AG
 * All rights reserved.                        
 *                                             
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the           
 * following conditions are met:   
 *                                                                              
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following   
 *   disclaimer.                        
 * 
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the    
 *   following disclaimer in the documentation and/or other materials provided with the distribution.     
 *                         
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote 
 *   products derived from this software without specific prior written permission. 
 *                                             
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,  
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE   
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,  
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR        
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,      
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE   
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.    
 *                                                                              
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes       
 * with Infineon Technologies AG (dave@infineon.com).        
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-16:
 *     - Initial version.      
 * 2015-03-18:
 *     - Guidelines updated.
 * 2015-04-23:
 *     - Updated the review comments from AEs.
 * 2015-06-20:
 *     - Updated the file header.
 * 2016-01-06:
 *     - Added the macro CLOCK_XMC4_USBCLK_ENABLED check to incorporate CLOCK_XMC4 APP changes.
 * 2016-02-10:
 *     - Removed the macro CLOCK_XMC4_USBCLK_ENABLED check and added the error message in UI.
 *     
 * @endcond 
 *
 */

#ifndef USBD_H
#define USBD_H

/***********************************************************************************************************************
 * HEADER FILES                                                                                                      
 **********************************************************************************************************************/
#include <xmc_usbd.h>
#include <xmc_common.h>
#include <DAVE_Common.h>
#include "./usbd_conf.h"

/**********************************************************************************************************************
 * MACROS                                                                                                            
 **********************************************************************************************************************/
#if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
       (XMC_LIB_MINOR_VERSION >= 0U) && \
       (XMC_LIB_PATCH_VERSION >= 0U)))
#error "USBD requires XMC Peripheral Library v2.0.0 or higher"
#endif

/**********************************************************************************************************************
 * ENUMS
 **********************************************************************************************************************/
/**
 * @ingroup USBD_enumerations
 * @{
 */
 /**
 * \brief State machine of Endpoint 0
 */
typedef enum USBD_EP0_STATE
{
	USBD_EP0_STATE_DISCONNECT, /**< Device is disconnected */
	USBD_EP0_STATE_IDLE, /**< Endpoint 0 is in IDLE state */
	USBD_EP0_STATE_IN_DATA, /**< Endpoint 0 is sending data */
	USBD_EP0_STATE_IN_STATUS, /**< Endpoint 0 sends a acknowledge to the host */
	USBD_EP0_STATE_OUT_DATA, /**< Endpoint 0 is reading data from the host */
	USBD_EP0_STATE_OUT_STATUS /**< Endpoint 0 waits for an acknowledge from the host */
}USBD_EP0_STATE_t;

/**
 * \brief USBD app status
 */
typedef enum USBD_STATUS
{
	USBD_STATUS_SUCCESS=0U,/**<Status of operation is Success*/
	USBD_STATUS_FAILURE=1U,/**<Status of operation is failure*/
	USBD_STATUS_ALREADY_INITIALIZED/**<USBD device already initialized*/
}USBD_STATUS_t;
/**
 * @}
 */

/**********************************************************************************************************************
 * DATA STRUCTURES
 **********************************************************************************************************************/
/**
 * @ingroup USBD_datastructures
 * @{
 */
/**
 * \brief USBD Endpoint
 *
 * Type define for a USBD Enpoint. This structure represents an endpoint.
 * It contains all necessary data to:
 * - control the state of the endpoint
 * - manage the data buffer
 *
 */
#if defined (__CC_ARM)
#pragma anon_unions
#endif
#if defined (__TASKING__)
/*https://issues.tasking.com/?issueid=101-37876*/
#pragma warning 586
#endif
typedef struct USBD_Endpoint {
	/**
	 * \name Endpoint Parameters
	 */
	/*@{*/
	union {
		uint32_t Address:8; /**< Full device address (including direction)  */
		struct {
			uint32_t Number:4; /**< Endpoint number */
			uint32_t :3;
			uint32_t Direction:1; /**< Endpoint direction */
		};

	};

	/* Endpoint flags */
	uint32_t IsConfigured:1; /**< Flag showing that the endpoint is configured */
	volatile uint32_t IsEnabled:1; /**< Flag showing that the endpoint is enabled */
	volatile uint32_t IsHalted:1; /**< Flag showing that the endpoint is halted */
	volatile uint32_t OutInUse:1; /**< Flag showing that the endpoint is in use as out */
	volatile uint32_t InInUse:1; /**< Flag showing that the endpoint is in use as in */
	volatile uint32_t IsOutRecieved:1; /**< Flag showing that an out packet has been received for that endpoint */
	uint32_t MaxPacketSize:7; /**< Maximum packet size for the endpoint */
	/*@}*/

	/**
	 * \name Out endpoint buffer management
	 */
	/*@{*/
	uint32_t OutBytesAvailable; /**< Amount of data in the out buffer */
	uint32_t OutOffset; /**< Amount of data that have been read from the buffer */
	uint8_t *OutBuffer; /**< Address of the out buffer */
	uint32_t OutBufferLength; /**< Length of the out buffer */
	/*@}*/

	/**
	 * \name In endpoint buffer management
	 */
	/*@{*/
	uint32_t InBytesAvailable; /**< Amount of data written into the buffer */
	uint8_t *InBuffer; /**< Address of in Buffer */
	uint32_t InBufferLength; /**< Length of the in buffer */
	uint32_t InDataLeft; /**< Data left in the in buffer to send */
	uint8_t* InDataBuffer; /**< Current start address of the in buffer */
	/*@}*/
} USBD_Endpoint_t;

#if defined (__TASKING__)
#pragma warning default
#endif

/**
 * USBD_event_callback-For top level APPs.
 * The following events are supported in USBD APP:\n
 * USB connect:\n
 * Event for USB device connection. This event fires when the microcontroller is in USB device mode and the device is
 * connected to a USB host, beginning the enumeration process measured by a rising level on the microcontroller's VBUS sense pin.
 * This event is time-critical; exceeding OS-specific delays within this event handler (typically of around two seconds) will
 * prevent the device from enumerating correctly.\n\n
 *
 * USB Disconnect:\n
 * Event for USB device disconnection. This event fires when the microcontroller is in USB device mode and the device is
 * disconnected from a host, measured by a falling level on the microcontroller's VBUS sense pin.\n\n
 *
 * Configuration Changed:\n
 * Event for USB configuration number changed. This event fires when a the USB host changes the selected configuration number.
 * This event should be hooked in device applications to create the endpoints and configure the device for the selected configuration.
 * This event is time-critical; exceeding OS-specific delays within this event handler (typically of around one second) will prevent
 * the device from enumerating correctly.\n\n
 *
 * Control Request:\n
 * Event for control requests. This event fires when a the USB host issues a control request to the mandatory device control
 * endpoint (of address 0). This may either be a standard request that the library may have a handler code for internally,
 * or a class specific request issued to the device which must be handled appropriately. If a request is not processed in the
 * user application via this event, it will be passed to the library for processing internally if a suitable handler exists.\n
 *
 * This event is time-critical; each packet within the request transaction must be acknowledged or sent within 50ms or the host
 * will abort the transfer.\n
 *
 * The library internally handles all standard control requests with the exceptions of SYNC FRAME,  SET DESCRIPTOR and
 * SET INTERFACE. These and all other non-standard control requests will be left for the user to process via this event if desired.
 * If not handled in the user application or by the library internally, unknown requests are automatically STALLed.\n\n
 *
 * Set Address:\n
 * USB set address event. This event gets fired when USB host requests the device to set the address.\n\n
 *
 * Get Descriptor:\n
 * USB Get descriptor event handler. This function is called by the library when in device mode. When the device receives a
 * Get Descriptor request on the control endpoint, this function is called so that the descriptor details can be passed back
 * and the appropriate descriptor sent back to the USB host.
 * The user has to send proper descriptor(device,configuration and string) and should return the size of the descriptor data.\n\n
 *
 * Wakeup Event:\n
 * Event for USB wake up. This event fires when a the USB interface is suspended while in device mode, and the host wakes up the
 * device by supplying Start Of Frame pulses. This is generally hooked to pull the user application out of a low power state and
 * back into normal operating mode.\n\n
 *
 * Suspend Event:\n
 * Event for USB suspend. This event fires when a the USB host suspends the device by halting its transmission of Start Of Frame
 * pulses to the device. This is generally hooked in order to move the device over to a low power state until the host wakes up the
 * device.\n\n
 *
 * SOF(Start Of Frame) Event:\n
 * Event for USB Start Of Frame detection, when enabled. This event fires at the start of each USB frame, once per millisecond, and
 * is synchronized to the USB bus. This can be used as an accurate millisecond timer source when the USB bus is enumerated in
 * device mode. This event is time-critical; it is run once per millisecond and thus will significantly degrade device performance.
 * This event should only be enabled when needed to reduce device wake-ups.\n\n
 *
 * Reset event:\n
 * Event for USB interface reset. This event fires when the USB interface is in device mode, and  the USB host requests that the
 * device reset its interface.
 * This event is time-critical; exceeding OS-specific delays within this event handler (typically of around  two seconds)
 * will prevent the device from enumerating correctly.
 *
 */
typedef struct USBD_Event_CB
{
	void (*connect)(void);      /**< Connect Event*/
	void (*disconnect)(void);   /**< Disconnect Event*/
	void (*config_changed)(void);    /**< Configuration changed Event*/
	void (*control_request)(void);    /**< Control Request Event*/
	void (*set_address)(void);       /**< Set Address Event*/
	uint16_t (*get_descriptor)(const uint16_t w_value, const uint16_t w_index,
			const void** const descriptor_address);/**< GetDescriptor Event*/
	void (*wakeup)(void);		/**< USB wakeup event*/
	void (*suspend)(void);		/**< USB suspend event*/
	void (*start_of_frame)(void);			/**< USB start of frame event.*/
	void (*reset)(void);           /**< Reset event*/
}USBD_Event_CB_t;

/**
 * USB device handle structure.Contains the configuration data for USB initialisation and the
 * event callbacks for USB events.
 *
 */
typedef struct USBD
{
	XMC_USBD_t usb_init;/*!< USB configuration data*/
	USBD_Event_CB_t *event_cb;/*!< USB event callbacks*/
}USBD_t;


/** \brief USBD Device
 *
 * Type define for an USB Device. This structure contains all the data for the USB Device Core Driver.
 * Especially the data of the endpoints are stored inside.
 */
typedef struct USBD_Device {
	XMC_USBD_DRIVER_t *Driver; /**< USB device controller driver structure */
	USBD_Endpoint_t Endpoints[7]; /**< Endpoint structures describing each endpoint of the device */

	uint8_t interface_settings[NUM_INTERFACES]; /**< Array of the currently selected alternate setting of an interface */
	uint8_t configuration; /**< Current USB device configuration */
	uint8_t pre_suspend_device_state; /**< The variable to store the XMC device state just before the USB suspend.*/
	USBD_EP0_STATE_t ep0_state; /**< Endpoint 0 state */
	uint8_t CurrentEndpoint; /**< Endpoint selected for the LUFA stack */
	uint8_t CurrentDirection; /**< Direction selected for the LUFA stack */
	uint8_t IsConfigured:1; /**< Flag shows that the device was successfully configured */
	volatile uint8_t IsSetupRecieved:1; /**< Flag hows that the setup packet is received */
	uint8_t remote_wakeup:1; /**< Flag shows that the feature Remote WakeUP is enabled */
	uint8_t self_powered:1; /**< Flag shows that the device is Self Powered */
	USBD_Event_CB_t *events;/**Pointer to USB event callback structure*/
} USB_Device_t;
/**
 * @}
 */

/*Include the extern declarations.*/
#include "usbd_extern.h"

/* Enable C linkage for C++ Compilers: */
#if defined(__cplusplus)
  extern "C" {
#endif

/***********************************************************************************************************************
 * API Prototypes
 **********************************************************************************************************************/
/**
 * @ingroup USBD_apidoc
 * @{
 */

/**
 * @brief The function initializes the USB core layer and makes the device ready to connect to USB host.
 * @param handle Pointer to USB device handle ::USBD_t
 * @return ::USBD_STATUS_t
 *
 * \par<b>Description:</b><br>
 *       This function :\n
 *       1) Initializes the USB core driver.\n
 *       2) Starts the USB device controller.\n\n
 *       In order to call USBD_Init()  following procedure should be
 *       followed:\n
 *       1) Call DAVE_Init().\n
 *       2) Call <APP>_Register_USBEvent_CB() to register the USB events including the mandatory events like
 *          ConfigChanged,ControlRequest and GetDescriptor.\n
 *       3) Call USBD_Init(USBD_handle) initialize the USB core in device mode.\n
 *
 * Example Usage:
 * @code
 *
 * #include <DAVE.h>
 *
 * USBD_Event_CB_t usb_events;
 *
 * int main(void)
 * {
 *   // Call the top level APP function to register the call-back.
 *   // The event callback functions need to be defined
 *   // <APP>_Register_USBEvent_CB(&usb_events);
 *
 *   if (USBD_Init(USBD_handle) == USBD_STATUS_SUCCESS)
 *   {
 *     if (USBD_Connect() != USBD_STATUS_SUCCESS)
 *     {
 *       return -1;
 *     }
 *   }
 *
 *   while (1)
 *   {
 *   }
 *
 *   return 0;
 * }
 *  @endcode <BR> </p>
 *
 * \note To start enumeration you need to call ::USBD_Connect to connect to the
 * host.
 */
USBD_STATUS_t USBD_Init(USBD_t *handle);


/**
 * @brief The function connects the USB device to the USB host
 * @param None
 * @return ::USBD_STATUS_t
 * \par<b>Description:</b><br>
 *  In order to call USBD_Connect()  following procedure should be
 *       followed:\n
 *       1) Call DAVE_Init().\n
 *       2) Call <APP>_Register_USBEvent_CB().\n
 *       3) Call USBD_Init(USBD_handle) initialize the USB core in device mode.\n
 *       4) Call USBD_Connect()
 * Example Usage:
 * @code
 *
 * #include <DAVE.h>
 *
 * USBD_Event_CB_t usb_events;
 *
 * int main(void)
 * {
 *   //Call the top level APP function to register the callback.
 *   //The event callback functions need to be defined
 *   //<APP>_Register_USBEvent_CB(&usb_events);
 *
 *   if (USBD_Init(USBD_handle) == USBD_STATUS_SUCCESS)
 *   {
 *     if (USBD_Connect() != USBD_STATUS_SUCCESS)
 *     {
 *       return -1;
 *     }
 *   }
 *
 *   while (1)
 *   {
 *   }
 *
 *   return 0;
 *  }
 *  @endcode <BR> </p>
 *
 */
USBD_STATUS_t USBD_Connect(void);


/**
 * @brief The function disconnects the USB device from the USB host
 * @param None
 * @return ::USBD_STATUS_t
 * \par<b>Description:</b><br>
 *       In order to call USBD_Disconnect()  following procedure should be
 *       followed:\n
 *       1) Call DAVE_Init().\n
 *       2) Call <APP>_Register_USBEvent_CB().\n
 *       3) Call USBD_Init(USBD_handle) initialize the USB core in device mode.\n
 *       4) Call USBD_Connect()
 *       5) After enumeration completion, call USBD_Disconnect()
 * Example Usage:
 * @code
 *
 * #include <DAVE.h>
 *
 * USBD_Event_CB_t usb_events;
 *
 * int main(void)
 * {
 *
 *   //Call the top level APP function to register the callback.
 *   //The event callback functions need to be defined
 *   //<APP>_Register_USBEvent_CB(&usb_events);
 *
 *   if (USBD_Init(USBD_handle) == USBD_STATUS_SUCCESS)
 *   {
 *     if (USBD_Connect() != USBD_STATUS_SUCCESS)
 *     {
 *       return -1;
 *     }
 *   }
 *
 *   while (1)
 *   {
 *     if (USBD_IsEnumDone())
 *     {
 *     	 USBD_Disconnect();
 *     	 break;
 *     }
 *   }
 *
 *   return 0;
 *  }
 *  @endcode <BR> </p>
 *
 */
USBD_STATUS_t USBD_Disconnect(void);



/**
 * @brief The function checks the USB enumeration completion status.
 * @param None
 * @return uint32_t\n
 * Returns 1; if the enumeration is complete; 0 otherwise.\n
 *
 * \par<b>Description:</b><br>
 *       In order to call USBD_IsEnumDone()  following procedure should be
 *       followed:\n
 *       1) Call DAVE_Init().\n
 *       2) Call <APP>_Register_USBEvent_CB().\n
 *       3) Call USBD_Init(USBD_handle) initialize the USB core in device mode.\n
 *       4) Call USBD_Connect()\n
 *       5) Call USBD_IsEnumDone(). \n
 *          Note that the user has to ensure the completion of class requests before doing the data transfer.\n
 * Example Usage:
 * @code
 *
 * #include <DAVE.h>
 * USBD_Event_CB_t usb_events;
 *
 * int main(void)
 * {
 *   static uint32_t enum_done = 0;
 *   // Call the top level APP function to register the callback.
 *   // The event callback functions need to be defined
 *   // <APP>_Register_USBEvent_CB(&usb_events);
 *
 *   if (USBD_Init(USBD_handle) == USBD_STATUS_SUCCESS)
 *   {
 *     if (USBD_Connect() != USBD_STATUS_SUCCESS)
 *     {
 *       return -1;
 *     }
 *   }
 *
 *
 *  while (1)
 *  {
 *    if (!enum_done)
 *    {
 *      enum_done = USBD_IsEnumDone();
 *      if (enum_done)
 *      {
 *        //Do the data transfer or endpoint settings on enumeration completion.
 *      }
 *    }
 *
 *    //Do the program logic
 *
 *  }
 *
 *  return 0;
 * }
 *  @endcode <BR> </p>
 *
 */
uint32_t USBD_IsEnumDone(void);



/**
 * @brief The function sets the endpoint buffers and configures the USB endpoints.
 * @param addr Endpoint address
 * @param buf Endpoint buffer
 * @param len Buffer size
 * @return None
 *
 * \par<b>Description:</b><br>
 *       In order to call USBD_SetEndpointBuffer()  following procedure should be
 *       followed:\n
 *       1) Call DAVE_Init().\n
 *       2) Call <APP>_Register_USBEvent_CB().\n
 *       3) Call USBD_Init(USBD_handle) initialize the USB core in device mode.\n
 *       4) Call USBD_Connect()
 *       5) In the configuration_changed event callback, call
 *          USBD_SetEndpointBuffer() before calling the function Endpoint_ConfigureEndpointTable().
 * Example Usage:
 * @code
 *
 * #include <DAVE.h>
 * USBD_Event_CB_t usb_events;
 * uint8_t ep_addr = 0x02;
 * uint8_t buf[64];
 * void EVENT_USB_Device_ConfigurationChanged(void);
 *
 * int main(void)
 * {
 *   usb_events.config_changed = EVENT_USB_Device_ConfigurationChanged;
 *   //Call the top level APP function to register the callback.
 *   //The event callback functions need to be defined
 *   //<APP>_Register_USBEvent_CB(&usb_events);
 *
 *   if (USBD_Init(USBD_handle) == USBD_STATUS_SUCCESS)
 *   {
 *     if (USBD_Connect() != USBD_STATUS_SUCCESS)
 *     {
 *       return -1;
 *     }
 *   }
 *
 *   while (1)
 *   {
 *
 *   }
 *
 *   return 0;
 * }
 *
 * void EVENT_USB_Device_ConfigurationChanged(void)
 * {
 *   USBD_SetEndpointBuffer(ep_addr,buf,64);
 *
 *   //Call top level APP endpoint configure API.
 *   //CDC_Device_ConfigureEndpoints(&USBD_VCOM_cdc_interface);
 *
 *   device.IsConfigured = 1;
 * }
 *
 *  @endcode <BR> </p>
 *
 */
void USBD_SetEndpointBuffer(uint8_t addr,uint8_t *buf,uint16_t len);

/**
 * @brief Get USBD APP version
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 *
 * \par<b>Description: </b><br>
 * The function can be used to check application software compatibility with a
 * specific version of the APP.
 *
 * Example Usage:
 *
 * @code
 * #include <DAVE.h>
 *
 * int main(void) {
 *
 *   DAVE_APP_VERSION_t version;
 *
 *   version = USBD_GetAppVersion();
 *   if (version.major != 4U) {
 *     // Probably, not the right version.
 *   }
 *
 *   // More code here
 *   while(1) {
 *
 *   }
 *   return (0);
 * }
 * @endcode<BR>
 */
DAVE_APP_VERSION_t USBD_GetAppVersion(void);


/**
 * @}
 */

/* Disable C linkage for C++ Compilers: */
#if defined(__cplusplus)
	}
#endif
#endif /* USBD_H_ */


